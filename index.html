<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Hệ Mặt Trời 3D Pastel + Vệ Tinh</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:black; font-family:Arial;}
#musicControl{
    position:absolute; top:20px; left:20px; z-index:10;
    background: rgba(0,0,0,0.5); padding:10px; border-radius:8px;color:white;
}
#musicControl input[type=file]{ display:block; margin-top:5px;}
#textureControl{
    position:absolute; top:150px; left:20px; z-index:10;
    background: rgba(0,0,0,0.5); padding:10px; border-radius:8px;color:white;
}
#textureControl input[type=file]{ display:block; margin-top:5px;}
</style>
</head>
<body>

<div id="musicControl">
  <div>Chọn file nhạc (MP3 hoặc M4A):</div>
  <input type="file" id="audioInput" accept=".mp3,.m4a"/>
  <audio id="audioPlayer" controls></audio>
</div>

<div id="textureControl">
  <div>Chọn texture cho Trái Đất (tuỳ chọn):</div>
  <input type="file" id="textureEarth" accept="image/*"/>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
<script>

// Scene, Camera, Renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enablePan=false;
controls.enableZoom=true;

// Starfield nhẹ
const starGeo = new THREE.BufferGeometry();
const starCount=1000;
const positions=[];
for(let i=0;i<starCount;i++){
  positions.push((Math.random()-0.5)*2000);
  positions.push((Math.random()-0.5)*2000);
  positions.push((Math.random()-0.5)*2000);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
const starMat = new THREE.PointsMaterial({color:0xffffff,size:0.5});
scene.add(new THREE.Points(starGeo,starMat));

// Lights
scene.add(new THREE.AmbientLight(0x888888));
const sunLight = new THREE.PointLight(0xffffff,2,0); sunLight.position.set(0,0,0); scene.add(sunLight);

// Rainbow Sun
const rainbowColors=[0xffadad,0xffd6a5,0xfdffb6,0xcaffbf,0x9bf6ff,0xa0c4ff,0xbdb2ff];
const sunGeo = new THREE.SphereGeometry(3,64,64);
const sunMat = new THREE.MeshBasicMaterial({color:0xfff1a4,emissive:0xffffaa});
const sun = new THREE.Mesh(sunGeo,sunMat);
scene.add(sun);

// Planets pastel + optional texture + halo sprites
const planets=[];
const planetData=[
  {name:'Mercury',size:0.5,distance:5,color:0xcfcfcf,satelliteCount:5},
  {name:'Venus',size:0.7,distance:7,color:0xffe0ac,satelliteCount:6},
  {name:'Earth',size:0.8,distance:10,color:0xa4d4ff,satelliteCount:8,textureInput:'textureEarth'},
  {name:'Mars',size:0.6,distance:13,color:0xffa3a3,satelliteCount:4},
  {name:'Jupiter',size:2,distance:18,color:0xffd1a4,satelliteCount:12},
  {name:'Saturn',size:1.7,distance:23,color:0xe0c4ff,satelliteCount:10},
  {name:'Uranus',size:1.3,distance:28,color:0xa0f0ff,satelliteCount:8},
  {name:'Neptune',size:1.2,distance:32,color:0x8080ff,satelliteCount:6},
];

const textureLoader = new THREE.TextureLoader();

planetData.forEach(p=>{
  let mat;
  if(p.textureInput){
    mat = new THREE.MeshStandardMaterial({color:p.color}); // fallback pastel
    // sẽ load texture từ input
  }else{
    mat = new THREE.MeshStandardMaterial({color:p.color});
  }

  const geom = new THREE.SphereGeometry(p.size,32,32);
  const mesh = new THREE.Mesh(geom,mat);
  mesh.position.x = p.distance;
  scene.add(mesh);

  // Halo/satellite sprites
  const satellites=[];
  for(let i=0;i<p.satelliteCount;i++){
    const sGeom = new THREE.SphereGeometry(p.size*0.1,8,8);
    const sMat = new THREE.MeshBasicMaterial({color:0x88ffff});
    const sat = new THREE.Mesh(sGeom,sMat);
    const angle = Math.random()*Math.PI*2;
    const radius = p.size + 0.5 + Math.random()*1;
    sat.userData = {angle:angle, radius:radius, speed:0.01+Math.random()*0.02};
    satellites.push(sat);
    mesh.add(sat);
  }

  planets.push({mesh:mesh, satellites:satellites, angle:Math.random()*Math.PI*2, distance:p.distance, speed:0.01+Math.random()*0.01, textureInput:p.textureInput});
});

// Camera intro
camera.position.set(0,50,100);
let introProgress=0;

// Animate
function animate(){
  requestAnimationFrame(animate);

  // Zoom intro
  if(introProgress<1){
    camera.position.lerp(new THREE.Vector3(0,10,40),0.01);
    introProgress+=0.005;
  }

  // Planets orbit
  planets.forEach(p=>{
    p.angle += p.speed;
    p.mesh.position.x = Math.cos(p.angle)*p.distance;
    p.mesh.position.z = Math.sin(p.angle)*p.distance;

    // Satellites rotation
    p.satellites.forEach(s=>{
      s.userData.angle += s.userData.speed;
      s.position.x = Math.cos(s.userData.angle)*s.userData.radius;
      s.position.z = Math.sin(s.userData.angle)*s.userData.radius;
    });
  });

  // Rainbow sun
  const t = Date.now()*0.001;
  const idx = Math.floor(t)%rainbowColors.length;
  sun.material.color.setHex(rainbowColors[idx]);

  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Audio MP3/M4A
const audioInput = document.getElementById('audioInput');
const audioPlayer = document.getElementById('audioPlayer');
audioInput.addEventListener('change', function(e){
  const file = e.target.files[0];
  if(file){
    const url = URL.createObjectURL(file);
    audioPlayer.src = url;
    audioPlayer.play().catch(()=>{});
  }
});

// Load texture Earth nếu user nhập
const textureEarthInput = document.getElementById('textureEarth');
textureEarthInput.addEventListener('change', function(e){
  const file = e.target.files[0];
  if(file){
    const url = URL.createObjectURL(file);
    const texture = textureLoader.load(url);
    const earth = planets.find(p=>p.textureInput==='textureEarth');
    if(earth) earth.mesh.material.map = texture;
    if(earth) earth.mesh.material.needsUpdate = true;
  }
});

</script>
</body>
</html>
