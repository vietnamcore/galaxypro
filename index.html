<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Hệ Mặt Trời 3D WebGL</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:black; font-family:Arial;}
#musicControl, #textureControl{
  position:absolute; left:20px; z-index:10;
  background: rgba(0,0,0,0.5); padding:10px; border-radius:8px; color:white;
}
#musicControl{ top:20px;}
#textureControl{ top:200px;}
#textureControl input[type=file]{ display:block; margin-top:5px;}
#applyTextureBtn{ margin-top:5px; padding:5px 10px; cursor:pointer;}
</style>
</head>
<body>

<div id="musicControl">
  <div>Chọn nhạc (MP3/M4A):</div>
  <input type="file" id="audioInput" accept=".mp3,.m4a"/>
  <audio id="audioPlayer" controls></audio>
</div>

<div id="textureControl">
  <div>Chọn texture hành tinh (tuỳ chọn):</div>
  <input type="file" id="textureEarth" accept="image/*"/>
  <button id="applyTextureBtn">Áp dụng texture</button>
</div>

<canvas id="glCanvas"></canvas>

<script>
// WebGL setup
const canvas = document.getElementById('glCanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if(!gl){
  alert('WebGL không được hỗ trợ trên trình duyệt này!');
}

// Basic shader
const vertexShaderSrc = `
attribute vec3 position;
uniform mat4 uMatrix;
void main(void){
  gl_Position = uMatrix * vec4(position,1.0);
}
`;

const fragmentShaderSrc = `
precision mediump float;
uniform vec4 uColor;
void main(void){
  gl_FragColor = uColor;
}
`;

function compileShader(src,type){
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

const vertexShader = compileShader(vertexShaderSrc, gl.VERTEX_SHADER);
const fragmentShader = compileShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);

const shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertexShader);
gl.attachShader(shaderProgram, fragmentShader);
gl.linkProgram(shaderProgram);
gl.useProgram(shaderProgram);

const uMatrix = gl.getUniformLocation(shaderProgram,'uMatrix');
const uColor = gl.getUniformLocation(shaderProgram,'uColor');

// Matrices
function identityMatrix(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
function perspective(fovy, aspect, near, far){
  const f = 1.0 / Math.tan(fovy/2);
  return [
    f/aspect,0,0,0,
    0,f,0,0,
    0,0,(far+near)/(near-far),-1,
    0,0,(2*far*near)/(near-far),0
  ];
}
function multiplyMatrices(a,b){
  const out = new Array(16).fill(0);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      for(let k=0;k<4;k++){
        out[i*4+j]+=a[i*4+k]*b[k*4+j];
      }
    }
  }
  return out;
}
function translationMatrix(x,y,z){ return [1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1]; }
function rotationYMatrix(angle){
  const c=Math.cos(angle), s=Math.sin(angle);
  return [c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1];
}

// Geometry: simple sphere approximation
function createSphere(radius, segments){
  const positions=[];
  for(let i=0;i<=segments;i++){
    const lat = i*Math.PI/segments;
    for(let j=0;j<=segments;j++){
      const lon = j*2*Math.PI/segments;
      const x = radius*Math.sin(lat)*Math.cos(lon);
      const y = radius*Math.cos(lat);
      const z = radius*Math.sin(lat)*Math.sin(lon);
      positions.push(x,y,z);
    }
  }
  return new Float32Array(positions);
}

// Create VBO
function createVBO(data){
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  return buffer;
}

// Setup sphere for sun + earth
const sunRadius = 3;
const earthRadius = 1;
const sunVBO = createVBO(createSphere(sunRadius,20));
const earthVBO = createVBO(createSphere(earthRadius,20));
const aPosition = gl.getAttribLocation(shaderProgram,'position');
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition,3,gl.FLOAT,false,0,0);

// Simple animation loop
let angle=0;
function animate(){
  angle+=0.01;
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  const proj = perspective(Math.PI/4, canvas.width/canvas.height,0.1,100);
  const view = translationMatrix(0,0,-20);

  // Draw Sun
  gl.bindBuffer(gl.ARRAY_BUFFER, sunVBO);
  gl.vertexAttribPointer(aPosition,3,gl.FLOAT,false,0,0);
  gl.uniform4fv(uColor,[1,0.8,0,1]);
  let model = identityMatrix();
  let mvp = multiplyMatrices(proj, multiplyMatrices(view, model));
  gl.uniformMatrix4fv(uMatrix,false,new Float32Array(mvp));
  gl.drawArrays(gl.POINTS,0,sunVBO.length/3);

  // Draw Earth
  gl.bindBuffer(gl.ARRAY_BUFFER, earthVBO);
  gl.vertexAttribPointer(aPosition,3,gl.FLOAT,false,0,0);
  gl.uniform4fv(uColor,[0.6,0.8,1,1]);
  model = translationMatrix(Math.cos(angle)*10,0,Math.sin(angle)*10);
  mvp = multiplyMatrices(proj, multiplyMatrices(view, model));
  gl.uniformMatrix4fv(uMatrix,false,new Float32Array(mvp));
  gl.drawArrays(gl.POINTS,0,earthVBO.length/3);

  requestAnimationFrame(animate);
}
animate();

// Audio
const audioInput=document.getElementById('audioInput');
const audioPlayer=document.getElementById('audioPlayer');
audioInput.addEventListener('change',function(e){
  const file = e.target.files[0];
  if(file){
    const url=URL.createObjectURL(file);
    audioPlayer.src=url;
    audioPlayer.play().catch(()=>{});
  }
});

// Texture Earth
document.getElementById('applyTextureBtn').addEventListener('click',()=>{
  alert('WebGL thuần cần shader nâng cao để áp dụng texture. Phiên bản này minh hoạ 3D và glow đơn giản.');
});

</script>
</body>
</html>
